{"version":3,"sources":["../../lib/08.js"],"names":["human","breathe","console","log","worker","__proto__","company","work","createAssigner","keysFunc","undefinedOnly","obj","length","arguments","index","source","keys","l","i","key","target","a","source1","b","source2","c","Object","assign"],"mappings":"AAAA;;AAEA;;;;AAIA;;AACA,IAAIA,QAAQ;AACVC,WAAS,SAASA,OAAT,GAAmB;AAC1BC,YAAQC,GAAR,CAAY,cAAZ;AACD;AAHS,CAAZ;AAKA,IAAIC,SAAS;AACXC,aAAWL,KADA,EACO;AAClBM,WAAS,YAFE;AAGXC,QAAM,SAASA,IAAT,GAAgB;AACpBL,YAAQC,GAAR,CAAY,YAAZ;AACD;AALU,CAAb;AAOAH,MAAMC,OAAN,G,CAAiB;AACjB;AACAG,OAAOH,OAAP,G,CAAkB;;;AAGlB,IAAIO,iBAAiB,SAASA,cAAT,CAAwBC,QAAxB,EAAkCC,aAAlC,EAAiD;AACpE,SAAO,UAAUC,GAAV,EAAe;AACpB,QAAIC,SAASC,UAAUD,MAAvB;AACA,QAAIA,SAAS,CAAT,IAAcD,OAAO,IAAzB,EAA+B,OAAOA,GAAP;AAC/B,SAAK,IAAIG,QAAQ,CAAjB,EAAoBA,QAAQF,MAA5B,EAAoCE,OAApC,EAA6C;AAC3C,UAAIC,SAASF,UAAUC,KAAV,CAAb;AAAA,UACIE,OAAOP,SAASM,MAAT,CADX;AAAA,UAEIE,IAAID,KAAKJ,MAFb,CAD2C,CAGtB;;AAErB;AACA;AACA;;;AAGA,WAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAID,CAApB,EAAuBC,GAAvB,EAA4B;AAC1B,YAAIC,MAAMH,KAAKE,CAAL,CAAV;AACA,YAAI,CAACR,aAAD,IAAkBC,IAAIQ,GAAJ,MAAa,KAAK,CAAxC,EAA2CR,IAAIQ,GAAJ,IAAWJ,OAAOI,GAAP,CAAX;AAC5C;AACD;AACA;AACA;AACA;AACA;AACD;AACD,WAAOR,GAAP;AACD,GAxBD;AAyBD,CA1BD;;AA4BA,IAAIS,SAAS,EAAEC,GAAG,CAAL,EAAb;;AAEA,IAAIC,UAAU,EAAEC,GAAG,CAAL,EAAd;AACA,IAAIC,UAAU,EAAEC,GAAG,CAAL,EAAd;;AAEAC,OAAOC,MAAP,CAAcP,MAAd,EAAsBE,OAAtB,EAA+BE,OAA/B;AACAtB,QAAQC,GAAR,CAAYiB,MAAZ,E,CAAqB","file":"08.js","sourcesContent":["'use strict';\n\n/**\r\n * Created by sks on 2017/4/26.\r\n */\n\n//通过对象字面量创建对象\nvar human = {\n  breathe: function breathe() {\n    console.log('breathing...');\n  }\n};\nvar worker = {\n  __proto__: human, //设置此对象的原型为human,相当于继承human\n  company: 'freelancer',\n  work: function work() {\n    console.log('working...');\n  }\n};\nhuman.breathe(); //输出 ‘breathing...’\n//调用继承来的breathe方法\nworker.breathe(); //输出 ‘breathing...’\n\n\nvar createAssigner = function createAssigner(keysFunc, undefinedOnly) {\n  return function (obj) {\n    var length = arguments.length;\n    if (length < 2 || obj == null) return obj;\n    for (var index = 1; index < length; index++) {\n      var source = arguments[index],\n          keys = keysFunc(source),\n          l = keys.length; //为什么这里要是1=keys.length??这样写是个什么意思？\n\n      // 看好了 人家是l 不是1 keys是函数keysFunc对source处理后的结果，\n      // 看函数名和后面写法返回的应该是一个数组，表示对象所有的键名，下面是对键名的遍历\n      // 所以 l = keys.length;  就是缓存键名数组的长度喽。\n\n\n      for (var i = 0; i < l; i++) {\n        var key = keys[i];\n        if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n      }\n      // 也可以下面这么写 不用l 但是效率要低一点 循环的条件是每次都要判断的，直接和具体的值比较比和数组的长度（一个属性）要快一些。\n      // for (var i = 0; i < keys.length; i++) {\n      //     var key = keys[i];\n      //     if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n      // }\n    }\n    return obj;\n  };\n};\n\nvar target = { a: 1 };\n\nvar source1 = { b: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\nconsole.log(target); // {a:1, b:2, c:3}"]}